BFS com matriz de adjacência:

visit(start node) 
queue <- start node 
WHILE queue is nor empty DO 
  x <- queue 
  FOR each y such that (x,y) is an edge 
                  and y has not been visited yet DO 
    visit(y) 
    queue <- y 
  END 
END 

********************************************************

bfs(matrix, starting_node, action):
  q <- new empty queue
  v <- new array of booleans, initialized all false
  enqueue(q, starting_node)
  while queue_not_empty(q):
    n <- dequeue(q)
    action(n)
    v[n] <- true
    for n' in neighbors_of(n, matrix):
      if not v[n']: enqueue(q, n')

**********************************************************

#include<stdio.h>
#include<conio.h>
int a[20][20],q[20],visited[20],n,i,j,f=0,r=-1;
void bfs(int v)
{
 for(i=1;i<=n;i++)
  if(a[v][i] && !visited[i])
   q[++r]=i;
 if(f<=r)
 {
  visited[q[f]]=1;
  bfs(q[f++]);
 }
}
void main()
{
 int v;
 clrscr();
 printf("\n Enter the number of vertices:");
 scanf("%d",&n);
 for(i=1;i<=n;i++)
 {
  q[i]=0;
  visited[i]=0;
 }
 printf("\n Enter graph data in matrix form:\n");
 for(i=1;i<=n;i++)
  for(j=1;j<=n;j++)
   scanf("%d",&a[i][j]);
 printf("\n Enter the starting vertex:");
 scanf("%d",&v);
 bfs(v);
 printf("\n The node which are reachable are:\n");
 for(i=1;i<=n;i++)
  if(visited[i])
   printf("%d\t",i);
  else
   printf("\n Bfs is not possible");
 getch();
}

******************************************************

#include

#define MAX 10

int n;
int adj[MAX][MAX
];
int visited[MAX];
void readmatrix()
{
    int i,j;
    printf("\nEnter the number of Vertices in the Graph : ");
    scanf("%d",&n);
    printf("\nEnter the Adjacency Matrix\n\n");
    for (i = 1; i <= n; i++)
        for (j = 1; j<= n; j++)
            scanf("%d",&adj[i][j]);
    for (i = 1; i <= n; i++)
        visited[i] = 0;
}

void bfs(int source)
{
    int queue[MAX];
    int i, front, rear, root;
    front = rear = 0;
    visited[source] = 1;
    queue[rear++] = source;
    printf("%d   ",source);
    while (front != rear)
    {
        root = queue[front];
        for (i = 1; i <= n; i++)
            if (adj[root][i] && !visited[i])
            {
                visited[i] = 1;
                queue[rear++] = i;
                printf("%d   ",i);
            }
        front++;
    }
}

int main()
{
    int source;
    printf("\n Program for Breadth First Search for a un-directed Graph");
    readmatrix();
    printf("\nEnter the Source : ");
    scanf("%d",&source);
    printf("\nThe nodes visited in the BFS order is : ");
    bfs(source);
    return 0;
}